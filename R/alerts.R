##' A function to send the NAV comparison alert.
##'
##' This is the description
##'
##' @param sSession The source session.
##' @param tSession The target session.
##' @param accounts The account mapping list.
##' @param type The type of container. Either 'accounts' or 'portfolios'.
##' @param resources The resources data frame.
##' @param days The lookback days for the consolidations.
##' @param ccy The currency to be valued in.
##' @param sDeployment The source deployment name.
##' @param tDeployment The target deployment name.
##' @param emailParams The email parameters.
##' @param gte Greater than or equal to time.
##' @param lte Less than or equal to time.
##' @param tz The time zone.
##' @param emailByTeam Email segregated by team.
##' @return NULL. Email with the alert will be sent.
##' @export
alertNAVComparison <- function(sSession,
                               tSession,
                               accounts,
                               type,
                               resources,
                               days=1,
                               ccy="USD",
                               sDeployment,
                               tDeployment,
                               emailParams,
                               gte="00:00:00",
                               lte="23:59:00",
                               tz="Asia/Singapore",
                               emailByTeam=FALSE) {

    ## Is it aler time?
    itsAlertTime <- itsTime(tz = tz, gte = gte, lte = lte)



    ## If it is not time, return NULL:
    if (!itsAlertTime) {
        return(NULL)
    }

    ## Get the account list:
    accounts <- accounts[safeGrep(names(accounts), "_") != "1"]

    ## Get the comparisons:
    comparisons <- decafNAVComparison(accounts,
                                      type,
                                      ccy,
                                      date=Sys.Date() - days,
                                      sSession,
                                      tSession,
                                      tDeployment,
                                      sDeployment,
                                      charLimit=100)

    ## Prepare email body:
    emailBody <- paste0(sprintf("This is a autogenerated alert for %s <-> %s Comparison. ", tDeployment, sDeployment),
                        "Find below the NAV comparison between your system and the source")

    ## Prepare the subject:
    subject <- sprintf(" DECAF NAV Comparison %s vs %s: ", tDeployment, sDeployment)

    ## Email By Team if required:
    if (emailByTeam) {

        ## Get teamwise trades:
        teamWise <- separateDFByTeam(comparisons, "ID", tSession)

        ## For each team, email report:
        lapply(teamWise, function(x) emailAlert(x[["df"]],
                                                x[["team"]],
                                                x[["users"]][, "email"],
                                                emailParams,
                                                provider="DECAF",
                                                caption=NULL,
                                                sourceType="API",
                                                emailBody,
                                                tDeployment,
                                                subject,
                                                tSession))

        ## Done, return:
        return(NULL)
    }

    ## Email data frame:
    emailAlert(comparisons,
               team=NULL,
               emailList=emailParams[["emailList"]],
               emailParams,
               provider="DECAF",
               caption=NULL,
               sourceType="API",
               emailBody,
               tDeployment,
               subject,
               tSession)

}


##' A function to send latest trades alert.
##'
##' This is the description
##'
##' @param session The rdecaf session.
##' @param resources The data-frame of the resources in the decaf instance.
##' @param days The number of days until the expiry.
##' @param emailParams The parameters for the email dispatch.
##' @param greeting The greetings string.
##' @param deployment The name of the deployment / client.
##' @param url The url of the deployment.
##' @param gte Greater than or equal to this time (HH:MM:SS) to run this alert.
##' @param lte Less than or equal to this time (HH:MM:SS) to run this alert.
##' @param tz The time-zone for gte and lte.
##' @param adhoc If TRUE, email gets send only if there are expiring instruments.
##' @return NULL. Email with the alert will be sent.
##' @export
alertBondCoupon <- function(session,
                            resources,
                            days,
                            emailParams,
                            greeting,
                            deployment,
                            url,
                            gte,
                            lte,
                            tz="UTC",
                            adhoc) {

    ## Is it alert time?
    itsAlertTime <- itsTime(tz = tz, gte = gte, lte = lte)

    ## If not alert time, return NULL:
    if (!itsAlertTime) {
        return(NULL)
    }

    ## Prepare stock params:
    params <- list(page_size = -1, format = "csv")

    ## Get the params:
    stocks <- as.data.frame(getResource("stocks", params=params, session=session))

    ## Get unique stocks:
    stocks <- stocks[!duplicated(stocks[, "artifact"]), ]

    ## Append the ctype to stocks:
    stocks[, "ctype"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "ctype"]

    ## Append the resource name:
    stocks[, "name"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "name"]

    ## Append the expiry:
    stocks[, "expiry"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "expiry"]

    ## Append the coupon
    stocks[, "pxmain"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "pxmain"]

    ## Append the frequency:
    stocks[, "frequency"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "frequency"]

    ## Append the issue:
    stocks[, "issued"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "issued"]

    ## Append the launch:
    stocks[, "launch"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "launch"]

    ## Append the convday:
    stocks[, "convday"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "convday"]

    ## Get the bonds:
    stocks <- stocks[stocks[, "ctype"] == "BOND", ]

    ## Get stocks with expiry:
    stocks <- stocks[!isNAorEmpty(stocks[, "expiry"]), ]

    ## If no expiries, exit:
    if (NROW(stocks) == 0 & adhoc){
        return(NULL)
    }

    ## If no expiries, mask:
    if (NROW(stocks) == 0) {
        stocks <- initDF(colnames(stocks), 1)
    }

    ## Infer the next coupons:
    stocks[, "nextCoupon"] <- as.character(apply(stocks, MARGIN=1, function(x) {
        as.character(jrvFinance::coupons.next(Sys.Date(), x["expiry"], as.numeric(x["frequency"])))
    }))

    ## Get the stocks with imminent expiry:
    stocks <- stocks[as.Date(stocks[, "nextCoupon"]) - Sys.Date() <= days, ]

    ## If no stocks, exit:
    if (NROW(stocks) == 0 & adhoc){
        return(NULL)
    }

    ## If no stocks, mask:
    if (NROW(stocks) == 0) {
        stocks <- initDF(colnames(stocks), 1)
    }

    ## Construct the consolidation links:
    resourceLink <- paste0(gsub("api", "", session[["location"]]), "resource/details/", stocks[, "artifact"])

    ## Prepare the result data frame:
    result <- data.frame("Name"=ellipsify(stocks[, "name"]),
                         "Type"=stocks[, "ctype"],
                         "Link"=resourceLink,
                         check.names = FALSE,
                         stringsAsFactors = FALSE)

    result[, "Link"] <- paste0("<a href='", result[, "Link"], "'>LINK</a>")

    result <- as.character(emailHTMLTable(result, provider = "DECAF",
                                          caption="Coupon Paying Bonds",
                                          sourceType = "API"))

    result <- gsub("&#62;LINK&#60;/a&#62;", ">LINK<aya/a>", result)
    result <- gsub("&#60;a href", "<a href", result)

    ## Prepare email body:
    emailBody <- paste0("Find below active bonds which will pay coupons within the next ",
                        days, " days. Please note, this the coupon payment dates may be ",
                        "derived theoretically using the instrument information available ",
                        "and may not be precise")

    ## Prepare the email content:
    .UPDATETEXT <- list(GREETINGPLACEHOLDER = greeting,
                        EMAILBODYPLACEHOLDER = emailBody,
                        CALLTOACTIONPLACEHOLDER = "Go to System",
                        DEPLOYMENT = deployment,
                        URLPLACEHOLDER = url,
                        FINALPARAGRAPHPLACEHOLDER = "Please contact us if you experience any issues or have questions/feedback.",
                        ADDRESSPLACEHOLDER = "",
                        GOODBYEPLACEHOLDER = "Best Regards,<br>DECAF TEAM",
                        ADDENDUMPLACEHOLDER = result)

    ## Send:
    syncUpdateEmail(template = readLines("../assets/update_email.html"),
                    updateText = .UPDATETEXT,
                    emailParams = emailParams,
                    subject = " DECAF Bond Coupon Alert: ")

}


##' A function to push a payload to a decaf instance.
##'
##' This is the description
##'
##' @param session The rdecaf session.
##' @param resources The data-frame of the resources in the decaf instance.
##' @param emailParams The parameters for the email dispatch.
##' @param occurThreshold For common instrument culprits, what is the occurance threshold? Default = 2.
##' @param greeting The greetings string.
##' @param deployment The name of the deployment / client.
##' @param url The url of the deployment.
##' @param gte Greater than or equal to this time (HH:MM:SS) to run this alert.
##' @param lte Less than or equal to this time (HH:MM:SS) to run this alert.
##' @param tz The time-zone for gte and lte.
##' @return NULL. Email with the alert will be sent.
##' @export
alertsComplianceBreachInspector <- function(session,
                                            resources,
                                            emailParams,
                                            occurThreshold=2,
                                            greeting,
                                            deployment,
                                            url,
                                            gte,
                                            lte,
                                            tz) {

    ## Is it alert time?
    itsAlertTime <- itsTime(tz=tz, gte=gte, lte=lte)

    ## If it is not alert time, return NULL:
    if (!itsAlertTime) {
        return(NULL)
    }

    ## Get the report:
    data <- complianceBreachInspector(resources, session, occurThreshold)

    ## This is a helper function:
    auxFun <- function(df, caption, footer) {

        !is.null(df) || return(NULL)

        ## Parse the instrument link:
        df[, "Link"] <- paste0("<a href='", df[, "Link"], "'>LINK</a>")

        ## Construct the indices for the row groups:
        rowGrpIdx <- as.numeric(diff(which(!isNAorEmpty(c(df[, "Common ID"], "TAIL")))))

        ## Prapare the row group parameter:
        rowGroups <- list(rowGrpIdx, df[!isNAorEmpty(df[, "Common ID"]), "Common ID"])

        if (any(sapply(rowGroups, length) == 0)) {
            rowGroups <- NULL
        }

        ## Prepare the alternative row background color indices:
        bgColorIdx <- which(!isNAorEmpty(c(df[, "Common ID"], "TAIL")))
        bgColorIdx <- apply(cbind(bgColorIdx, c(tail(bgColorIdx, -1), NROW(df))), MARGIN=1, function(x) tail(x[1]:x[2], -1))

        ## Get rid of tail of bgColorIdx if length is more than 1:
        if (length(bgColorIdx) > 1) {
            bgColorIdx <- bgColorIdx[-length(bgColorIdx)]
        }

        ## Assign the background color indices to the list:
        rowBGColor <- list()
        rowBGColor[["rowsOdd"]] <- as.numeric(unlist(bgColorIdx[seq(1, length(bgColorIdx), 2)]))
        rowBGColor[["rowsEvn"]] <- as.numeric(unlist(bgColorIdx[seq(min(2, length(bgColorIdx)), length(bgColorIdx), 2)]))

        ## Remove the Common ID column:
        df[, "Common ID"] <- NULL

        ## Prepare the html table and return:
        emailHTMLTable(df,
                       provider=NULL,
                       caption=caption,
                       sourceType="API",
                       rowGroups=rowGroups,
                       rowBGColor=rowBGColor,
                       collapse="separate",
                       spacing="4px",
                       footer=footer)
    }

    ## HTMLize data frames and combine the tables:
    result <- paste0(as.character(auxFun(data[["culpritsWithoutAClass"]], "Common Culprits Without Asset Class", "")),
                     as.character(auxFun(data[["culpritsWithAClass"]], "Common Culprits With Asset Class", NULL)),
                     collapse="")

    ## Clean the HTML text:
    result <- gsub("&#62;LINK&#60;/a&#62;", ">LINK<aya/a>", result)
    result <- gsub("&#60;a href", "<a href", result)

    emailBody <- paste0("Please find below a list of instruments which commonly appear in compliance breaches. ",
                        "We advice to assign the appropriate asset class to the missing ones and to review the ",
                        "asset class assignment for the existing ones. Please note that this is not a exaustive ",
                        "list of instruments for either case. ")

    ## Construct the text:
    UPDATETEXT <- list("GREETINGPLACEHOLDER"="Dear SAWM Team",
                       "EMAILBODYPLACEHOLDER"=emailBody,
                       "CALLTOACTIONPLACEHOLDER"="Go to System",
                       "DEPLOYMENT"="SwissAsia WM",
                       "URLPLACEHOLDER"=gsub("api", "", session[["location"]]),
                       "FINALPARAGRAPHPLACEHOLDER"="Please contact us if you experience any issues or have questions/feedback.",
                       "ADDRESSPLACEHOLDER"="",
                       "GOODBYEPLACEHOLDER"="Best Regards,<br>DECAF TEAM",
                       "ADDENDUMPLACEHOLDER"=result)

    ## Send it:
    syncUpdateEmail(template=readLines("../assets/update_email.html"),
                     updateText=UPDATETEXT,
                     emailParams=emailParams,
                     subject=" DECAF Compliance Inspector: ")

}


##' A function to push a payload to a decaf instance.
##'
##' This is the description
##'
##' @param accounts The data-frame with the rdecaf accounts. If NULL, all accounts of session are considered. Default is NULL.
##' @param resources The data-frame of the resources in the decaf instance.
##' @param session The rdecaf session.
##' @return A data-frame of positions which are duplicated in terms of isin.
##' @import rdecaf
##' @export
duplicatedIsinInPortfolios <- function(accounts=NULL, resources, session) {

    ## If no accounts given, retriev all accounts:
    if (is.null(accounts)) {
        ## Get system accounts:
        accounts <- as.data.frame(getResource("accounts", params=list("page_size"=-1, "format"="csv"), session=session))
    }

    ## Get the account wise positions:
    stocks <- getDBObject("stocks", session)

    ## Get the enriched stocks:
    stocks <- getEnrichedStocks(stocks, accounts, resources)

    ## Append the portfolio id:
    stocks[, "portfolio"] <- accounts[match(stocks[, "account"], accounts[, "id"]), "portfolio"]

    ## Append the portfolio id:
    stocks[, "portfolio_name"] <- accounts[match(stocks[, "account"], accounts[, "id"]), "portfolio_name"]

    ## Get the portfolio wise stocks:
    pWiseStocks <- lapply(unique(stocks[, "portfolio"]), function(x) stocks[stocks[, "portfolio"] == x, ])

    ## Iterate over list and return duplicate positions with duplicate isin:
    pWiseStocks <- safeRbind(lapply(1:length(pWiseStocks), function(i) {

        ## Get the current list element:
        pWS <- pWiseStocks[[i]]

        ## Which stocks are duplicated in terms of isin:
        pWS[, "duplIsin"] <- duplicated(pWS[, "isin"])

        ## Filter out rows of which the isin field is not an isin:
        pWS <- pWS[isIsin(pWS[,"isin"]), ]

        ## If there are any rows, return such:
        if (any(pWS[, "duplIsin"])) {
            return(pWS[pWS[, "duplIsin"], ])
        } else {
            ## Else return NULL:
            return(NULL)
        }
    }))

    ## If there are now duplicates, return NULL:
    if (NROW(pWiseStocks) == 0){
        return(NULL)
    }

    ## Return the data-frame with duplicate isins in portfolio:
    data.frame("Portfolio"=pWiseStocks[, "portfolio_name"],
               "ISIN"=pWiseStocks[,"isin"],
               "Symbol"=pWiseStocks[, "symbol"],
               "Name"=pWiseStocks[, "name"])
}


##' A function prepares the performance outliers data-frame
##'
##' This is the description
##'
##' @param portfolio The portfolio id,
##' @param start The start date of the performance. Default is start of the current year.
##' @param factor The factor to sd()
##' @param session The rdecaf session.
##' @return A data-frame with outliers.
##' @import rdecaf
##' @export
performanceOutliers <- function(portfolio, start=NULL, factor=8, session) {

    if (is.null(start)) {
        ## Get the year start:
        start <- paste0(substr(Sys.Date(), 1, 4), "-01-01")

    }

    print(portfolio)

    ## Construct the parameters:
    params <- list("portfolios"=portfolio,
                   "start"=start)

    ## Get the performance data:
    performance <- try(getResource("performance", params=params, session=session), silent=TRUE)

    link <- paste0(gsub("api", "", session[["location"]]),
                   "dashboard/performance?portfolios=", portfolio,
                   "&start=", as.character(start))

    if (class(performance) == "try-error") {
        return(data.frame("Portfolio"=portfolio,
                          "Date"="ERROR",
                          "Return"="ERROR",
                          "Link to Performance"=link,
                          check.names=FALSE,
                          stringsAsFactors=FALSE))
    }

    ## Get the returns:
    returns <- unlist(performance[["returns"]][["data"]])

    ## Get the date index:
    index <- unlist(performance[["returns"]][["index"]])

    ## If no returns, return NULL:
    if (is.null(returns)) {
        return(NULL)
    }

    ## Make zoo:
    xtsReturns <- data.frame("returns"=xts::as.xts(returns, order.by=as.Date(index)))

    ## Get the outliersxs:
    outliers <- returnOutliers(xtsReturns, factor)

    ## Return outlier observations:
    if (any(outliers)) {
        return(data.frame("Portfolio"=portfolio,
                          "Date"=as.character(rownames(xtsReturns)[outliers]),
                          "Return"=round(as.numeric(xtsReturns[outliers,]), 4),
                          "Link to Performance"=link,
                          check.names=FALSE,
                          stringsAsFactors=FALSE))
    }

    ## Return:
    NULL
}


##' A function to send latest trades alert.
##'
##' This is the description
##'
##' @param session The rdecaf session.
##' @param accounts The data-frame with the rdecaf accounts.
##' @param resources The data-frame of the resources in the decaf instance.
##' @param emailParams The parameters for the email dispatch.
##' @param exclType The resource type to be excluded.
##' @param hours The number of hours to look back.
##' @param greeting The greetings string.
##' @param deployment The name of the deployment / client.
##' @param url The url of the deployment.
##' @param gte Greater than or equal to this time (HH:MM:SS) to run this alert.
##' @param lte Less than or equal to this time (HH:MM:SS) to run this alert.
##' @param tz The time-zone for gte and lte.
##' @return NULL. Email with the alert will be sent.
##' @export
alertLatestTrades <- function(session,
                              accounts,
                              resources,
                              emailParams,
                              exclType="CCY",
                              hours=24,
                              greeting="",
                              deployment="",
                              url="",
                              gte="10:01:00",
                              lte="10:19:00",
                              tz="UTC") {

    ## Is it alert time?
    itsAlertTime <- itsTime(tz=tz, gte=gte, lte=lte)

    ## If it is not alert time, return NULL:
    if (!itsAlertTime) {
        return(NULL)
    }

    ## Prepare the params for the trades:
    params <- list("page_size"=-1, "format"="csv", "commitment__gte"=Sys.Date() - 90)

    ## Get the trades:
    trades <- as.data.frame(getResource("trades", params=params, session=session))

    ## Filter out the cash trades:
    trades <- trades[trades[, "resmain_ctype"] != exclType, ]

    ## Filter the latest trades:
    trades <- trades[difftime(as.POSIXct(format(Sys.time(), tz="UTC")), as.POSIXct(trades[, "created"]), units="hours") < hours, ]

    ## If no trades, mask trade data frame:
    if (NROW(trades) == 0) {
        trades <- initDF(colnames(trades), 1)
    }

    ## Construct the trade links:
    tradeLink <- paste0(gsub("api", "", session[["location"]]), "trade/details/", trades[, "id"])

    ## Construct the report email data-frame:
    result <- data.frame("Trade Link"=tradeLink,
                         "Account"=trades[, "accmain_name"],
                         "Type"=resources[match(trades[, "resmain"], resources[, "id"]), "ctype"],
                         "Symbol"=ellipsify(trades[, "resmain_symbol"], 16),
                         "Name"=ellipsify(resources[match(trades[, "resmain"], resources[, "id"]), "name"], 25),
                         "Trade Date"=trades[, "commitment"],
                         "QTY"=beautify(as.character(round(as.numeric(trades[, "qtymain"]), 2)), nsmall=2),
                         "PX"=beautify(as.character(round(as.numeric(trades[, "pxmain"]), 2)), nsmall=2),
                         check.names=FALSE,
                         stringsAsFactors=FALSE)

    ## HTMLize the links:
    result[, "Trade Link"] <- paste0("<a href='", result[, "Trade Link"], "'>LINK</a>")

    ## Generate the outlier table as HTML and convert to string:
    result <- as.character(emailHTMLTable(result,
                                          provider="DECAF",
                                          caption=paste0("Trades Created In The Last ", hours, " Hours"),
                                          sourceType="API"))

    ## Clean the HTML text:
    result <- gsub("&#62;LINK&#60;/a&#62;", ">LINK<aya/a>", result)
    result <- gsub("&#60;a href", "<a href", result)

    .UPDATETEXT <- list("GREETINGPLACEHOLDER"=greeting,
                        "EMAILBODYPLACEHOLDER"="Your DECAF system has been updated with the latest data snapshots available ",
                        "CALLTOACTIONPLACEHOLDER"="Go to System",
                        "DEPLOYMENT"=deployment,
                        "URLPLACEHOLDER"=url,
                        "FINALPARAGRAPHPLACEHOLDER"="Please contact us if you experience any issues or have questions/feedback.",
                        "ADDRESSPLACEHOLDER"="",
                        "GOODBYEPLACEHOLDER"="Best Regards,<br>DECAF TEAM",
                        "ADDENDUMPLACEHOLDER"=result)

    syncUpdateEmail(template=readLines("../assets/update_email.html"),
                     updateText=.UPDATETEXT,
                     emailParams=emailParams,
                     subject=" DECAF Data Update: ")

}


##' A function to send latest trades alert.
##'
##' This is the description
##'
##' @param session The rdecaf session.
##' @param resources The data-frame of the resources in the decaf instance.
##' @param days The number of days until the expiry.
##' @param emailParams The parameters for the email dispatch.
##' @param greeting The greetings string.
##' @param deployment The name of the deployment / client.
##' @param url The url of the deployment.
##' @param gte Greater than or equal to this time (HH:MM:SS) to run this alert.
##' @param lte Less than or equal to this time (HH:MM:SS) to run this alert.
##' @param tz The time-zone for gte and lte.
##' @param adhoc If TRUE, email gets send only if there are expiring instruments.
##' @return NULL. Email with the alert will be sent.
##' @export
alertExpiry <- function (session,
                         resources,
                         days=7,
                         emailParams,
                         greeting = "",
                         deployment = "",
                         url= "",
                         gte="10:01:00",
                         lte="10:19:00",
                         tz="UTC",
                         adhoc=FALSE) {

    ## Is it alert time?
    itsAlertTime <- itsTime(tz = tz, gte = gte, lte = lte)

    ## If not alert time, return NULL:
    if (!itsAlertTime) {
        return(NULL)
    }

    ## Prepare stock params:
    params <- list(page_size = -1, format = "csv")

    ## Get the params:
    stocks <- as.data.frame(getResource("stocks", params=params, session=session))

    ## Get unique stocks:
    stocks <- stocks[!duplicated(stocks[, "artifact"]), ]

    ## Append the ctype to stocks:
    stocks[, "ctype"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "ctype"]

    ## Append the resource name:
    stocks[, "name"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "name"]

    ## Append the expiry:
    stocks[, "expiry"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "expiry"]

    ## Get stocks with expiry:
    stocks <- stocks[!isNAorEmpty(stocks[, "expiry"]), ]

    ## If no expiries, exit:
    if (NROW(stocks) == 0 & adhoc){
        return(NULL)
    }

    ## If no expiries, mask:
    if (NROW(stocks) == 0) {
        stocks <- initDF(colnames(stocks), 1)
    }

    ## Get the stocks with imminent expiry:
    stocks <- stocks[as.Date(stocks[, "expiry"]) - Sys.Date() <= days, ]

    ## If no overdrafts, mask:
    if (NROW(stocks) == 0) {
        stocks <- initDF(colnames(stocks), 1)
    }

    ## Construct the consolidation links:
    resourceLink <- paste0(gsub("api", "", session[["location"]]), "resource/details/", stocks[, "artifact"])

    ## Prepare the result data frame:
    result <- data.frame("Name"=ellipsify(stocks[, "name"]),
                         "Type"=stocks[, "ctype"],
                         "Link"=resourceLink,
                         check.names = FALSE,
                         stringsAsFactors = FALSE)

    result[, "Link"] <- paste0("<a href='", result[, "Link"], "'>LINK</a>")

    result <- as.character(emailHTMLTable(result, provider = "DECAF",
                                          caption="Expiring Instruments",
                                          sourceType = "API"))

    result <- gsub("&#62;LINK&#60;/a&#62;", ">LINK<aya/a>", result)
    result <- gsub("&#60;a href", "<a href", result)

    .UPDATETEXT <- list(GREETINGPLACEHOLDER = greeting,
                        EMAILBODYPLACEHOLDER = paste0("Find below active instruments which will expire within the next ", days, " days or have already expired"),
                        CALLTOACTIONPLACEHOLDER = "Go to System",
                        DEPLOYMENT = deployment,
                        URLPLACEHOLDER = url,
                        FINALPARAGRAPHPLACEHOLDER = "Please contact us if you experience any issues or have questions/feedback.",
                        ADDRESSPLACEHOLDER = "",
                        GOODBYEPLACEHOLDER = "Best Regards,<br>DECAF TEAM",
                        ADDENDUMPLACEHOLDER = result)

    syncUpdateEmail(template = readLines("../assets/update_email.html"),
                    updateText = .UPDATETEXT,
                    emailParams = emailParams,
                    subject = " DECAF Expiring Instruments Alert: ")

}


##' A function to send latest trades alert.
##'
##' This is the description
##'
##' @param session The rdecaf session.
##' @param resources The data-frame of the resources in the decaf instance.
##' @param emailParams The parameters for the email dispatch.
##' @param greeting The greetings string.
##' @param deployment The name of the deployment / client.
##' @param url The url of the deployment.
##' @param gte Greater than or equal to this time (HH:MM:SS) to run this alert.
##' @param lte Less than or equal to this time (HH:MM:SS) to run this alert.
##' @param tz The time-zone for gte and lte.
##' @return NULL. Email with the alert will be sent.
##' @export
alertOverdraft <- function (session,
                            resources,
                            emailParams,
                            greeting = "",
                            deployment = "",
                            url = "",
                            gte = "10:01:00",
                            lte = "10:19:00",
                            tz = "UTC") {

    ## Is it alert time?
    itsAlertTime <- itsTime(tz = tz, gte = gte, lte = lte)

    ## If not alert time, return NULL:
    if (!itsAlertTime) {
        return(NULL)
    }

    ## Get system accounts:
    systemAccounts <- as.data.frame(getResource("accounts", params=list("page_size"=-1, "format"="csv"), session=session))

    ## Prepare stock params:
    params <- list(page_size = -1, format = "csv")

    ## Get the params:
    stocks <- as.data.frame(getResource("stocks", params=params, session=session))

    ## Append the ctype to stocks:
    stocks[, "ctype"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "ctype"]

    ## Append the resource name:
    stocks[, "name"] <- resources[match(stocks[, "artifact"], resources[, "id"]), "name"]

    ## Append account name:
    stocks[, "acctype"] <- systemAccounts[match(stocks[, "account"], systemAccounts[, "id"]), "atype"]

    ## Append account name:
    stocks[, "accname"] <- systemAccounts[match(stocks[, "account"], systemAccounts[, "id"]), "name"]

    ## Append portfolio name:
    stocks[, "portname"] <- systemAccounts[match(stocks[, "account"], systemAccounts[, "id"]), "portfolio_name"]

    ## Get the CCY type stocks:
    cashStocks <- stocks[stocks[, "ctype"] == "CCY" & is.na(stocks[, "acctype"]), ]

    ## Get the overdrafts:
    overdrafts <- cashStocks[cashStocks[, "quantity"] < 0, ]

    ## If no overdrafts, mask:
    if (NROW(overdrafts) == 0) {
        overdrafts <- initDF(colnames(overdrafts), 1)
    }

    ## Construct the consolidation links:
    consolidationLink <- paste0(gsub("api", "", session[["location"]]), "consolidation?i=", overdrafts[, "account"])

    ## Prepare the result data frame:
    result <- data.frame("Consolidation"= consolidationLink,
                         "Account"=overdrafts[, "accname"],
                         "Portfolio"=overdrafts[, "portname"],
                         "Currency"=overdrafts[, "name"],
                         "Amount"=overdrafts[, "quantity"],
                         check.names = FALSE,
                         stringsAsFactors = FALSE)

    result[, "Consolidation"] <- paste0("<a href='", result[, "Consolidation"], "'>LINK</a>")

    result <- as.character(emailHTMLTable(result, provider = "DECAF",
                                          caption="Cash Overdrafts",
                                          sourceType = "API"))

    result <- gsub("&#62;LINK&#60;/a&#62;", ">LINK<aya/a>", result)
    result <- gsub("&#60;a href", "<a href", result)

    .UPDATETEXT <- list(GREETINGPLACEHOLDER = greeting,
                        EMAILBODYPLACEHOLDER = "Find below custody accounts which have a cash overdraft",
                        CALLTOACTIONPLACEHOLDER = "Go to System",
                        DEPLOYMENT = deployment,
                        URLPLACEHOLDER = url,
                        FINALPARAGRAPHPLACEHOLDER = "Please contact us if you experience any issues or have questions/feedback.",
                        ADDRESSPLACEHOLDER = "",
                        GOODBYEPLACEHOLDER = "Best Regards,<br>DECAF TEAM",
                        ADDENDUMPLACEHOLDER = result)

    syncUpdateEmail(template = readLines("../assets/update_email.html"),
                    updateText = .UPDATETEXT,
                    emailParams = emailParams,
                    subject = " DECAF Overdraft Alert: ")
}



##' A function to .
##'
##' This is the description
##'
##' @param session The rdecaf session.
##' @param resources The data-frame of the resources in the decaf instance.
##' @param emailParams The parameters for the email dispatch.
##' @param greeting The greetings string.
##' @param deployment The name of the deployment / client.
##' @param url The url of the deployment.
##' @param gte Greater than or equal to this time (HH:MM:SS) to run this alert.
##' @param lte Less than or equal to this time (HH:MM:SS) to run this alert.
##' @param tz The time-zone for gte and lte.
##' @return NULL. Email with the alert will be sent.
##' @export
alertMissingMonthEndPx <- function (session,
                                    resources,
                                    emailParams,
                                    greeting="Dear Team,",
                                    deployment,
                                    url,
                                    gte="00:00:00",
                                    lte="23:59:00",
                                    tz="UTC") {

    ## Check if  parameters are defined:
    if (!hasArg("session") || !hasArg("resources") || !hasArg("emailParams") || !hasArg("deployment") || !hasArg("url")) {
        stop("Need to define session / resources / emailsParams / deployment / url")
    }

    ## Is it alert time:
    itsAlertTime <- itsTime(tz=tz, gte=gte, lte=lte)

    ## If not, return NULL
    if (!itsAlertTime) {
        return(NULL)
    }

    # Off days
    offdays <- c("Saturday", "Sunday")

    ## Say you want to find out last working date of December 2017
    monthdates <- tail(seq(dateOfPeriod("M-1"), dateOfPeriod("M-0"), 1), -1)

    ## Eliminate off days
    monthdates<- monthdates[!weekdays(monthdates) %in% offdays]

    ## Find out max date in vector now
    rDate <- max(monthdates)

    ## The params:
    params <- list(page_size = -1, format = "csv", date=rDate)

    ## Get portfolios:
    stocks <- as.data.frame(getResource("stocks", params=params, session=session))

    ## Prepare the ohlc query:
    ohlcData <- resources[match(unique(stocks[, "artifact"]), resources[, "id"]), c("ohlccode", "symbol", "ctype", "id", "name")]

    ohlcData[, "priceId"] <- ifelse(isNAorEmpty(ohlcData[, "ohlccode"]), ohlcData[, "symbol"], ohlcData[, "ohlccode"])

    ohlcObs <- lapply(ohlcData[, "priceId"], function(x) getOhlcObsForSymbol(session, x, lte=as.Date(rDate), lookBack=0))

    ohlcData[, "monthEndPx"] <- as.numeric(sapply(ohlcObs, function(x) ifelse(NROW(x) == 0, NA, x[, "close"])))

    ohlcData <- ohlcData[ohlcData[, "ctype"] != "OTHER" & ohlcData[, "ctype"] != "CCY" & ohlcData[, "ctype"] != "FXFWD", ]

    ohlcData <- ohlcData[is.na(ohlcData[, "monthEndPx"]), ]

    if (NROW(ohlcData) == 0) {
        ohlcData <- initDF(colnames(ohlcData), 1)
    }

    instrumentLink <- paste0(gsub("api", "", session[["location"]]), "ohlc/observation?series__symbol=", ohlcData[, "priceId"])
    instrumentLink <- gsub(" ", "%20", instrumentLink)

    result <- data.frame("OHLC Link"=instrumentLink,
                         "Name"=ohlcData[, "name"],
                         "Symbol"=ohlcData[, "symbol"],
                         check.names=FALSE,
                         stringsAsFactors=FALSE)


    result[, "OHLC Link"] <- paste0("<a href='", result[, "OHLC Link"], "'>LINK</a>")

    result <- as.character(emailHTMLTable(result,
                                          provider = "DECAF",
                                          caption="Missing Month-End Prices",
                                          sourceType = "API"))

    result <- gsub("&#62;LINK&#60;/a&#62;", ">LINK<aya/a>", result)
    result <- gsub("&#60;a href", "<a href", result)

    attachment <- data.frame("date"=rDate, "symbol"=ohlcData[, "priceId"], "close"=NA, stringsAsFactors=FALSE)
    rownames(attachment) <- NULL
    fPath <- gsub(":", "" ,gsub(" ", "_", paste0("/tmp/monthend_prices__", Sys.time(), ".csv")))
    write.csv(attachment, fPath, row.names=FALSE)

    .UPDATETEXT <- list(GREETINGPLACEHOLDER = greeting,
                        EMAILBODYPLACEHOLDER = "Please find below instruments for which the month end prices are missing",
                        CALLTOACTIONPLACEHOLDER = "Go to System",
                        DEPLOYMENT = deployment,
                        URLPLACEHOLDER = url,
                        FINALPARAGRAPHPLACEHOLDER = "Please contact us if you experience any issues or have questions/feedback",
                        ADDRESSPLACEHOLDER = "",
                        GOODBYEPLACEHOLDER = "Best Regards,<br>DECAF TEAM",
                        ADDENDUMPLACEHOLDER = result)

    syncUpdateEmail(template = readLines("../assets/update_email.html"),
                    updateText = .UPDATETEXT,
                    emailParams = emailParams,
                    subject = " DECAF Month-End Price Alert: ",
                    attachments=fPath)
}


##' A function to .
##'
##' This is the description
##'
##' @param session The rdecaf session.
##' @param resources The data-frame of the resources in the decaf instance.
##' @param emailParams The parameters for the email dispatch.
##' @param greeting The greetings string.
##' @param deployment The name of the deployment / client.
##' @param url The url of the deployment.
##' @param gte Greater than or equal to this time (HH:MM:SS) to run this alert.
##' @param lte Less than or equal to this time (HH:MM:SS) to run this alert.
##' @param tz The time-zone for gte and lte.
##' @param stockOnly Shall we check only open positions? Default: TRUE
##' @param emailList Optionally, a vector with email addressess to overwrite emailParams.
##' @param excludeType The ctypes of resources to be excluded. A vector. Default is 'CCY'.
##' @return NULL. Email with the alert will be sent.
##' @export
alertMissingAssetClass <- function (session,
                                    resources,
                                    emailParams,
                                    greeting="Dear Team,",
                                    deployment,
                                    url,
                                    gte="00:00:00",
                                    lte="23:59:00",
                                    tz = "UTC",
                                    stockOnly=TRUE,
                                    emailList=NULL,
                                    excludeType="CCY") {

    ## Check if  parameters are defined:
    if (!hasArg("session") || !hasArg("resources") || !hasArg("emailParams") || !hasArg("deployment") || !hasArg("url")) {
        stop("Need to define session / resources / emailsParams / deployment / url")
    }

    ##:
    if (!is.null(emailList)) {
        emailParams[["emailList"]] <- emailList
    }

    ## Is it alert time:
    itsAlertTime <- itsTime(tz=tz, gte=gte, lte=lte)

    ## If not, return NULL
    if (!itsAlertTime) {
        return(NULL)
    }

    if (stockOnly) {

        ## Get the stocks:
        stocks <- as.data.frame(getResource("stocks", params=list("page_size"=1, "format"="csv"), session=session))

        resources <- resources[!is.na(match(resources[, "id"], unique(stocks[, "artifact"]))), ]

        ## resByAssetClass <- resources[match(stocks[, "artifact"], resources[, "id"]), c("symbol", "assetclass", "id", "ctype", "name")]
        ## resources <- resources[match(stocks[, "artifact"], resources[, "id"]), c("symbol", "assetclass", "id", "ctype", "name")]

    }

    ## Exclude certain ctypes from consideration:
    resources <- resources[apply(mgrep(resources[, "ctype"], excludeType), MARGIN=1, function(x) all(x == "0")), ]

    resources <- resources[, c("symbol", "assetclass", "id", "ctype", "name")]

    missingAssetClass <- resources[is.na(resources[, "assetclass"]), ]

    if (NROW(missingAssetClass) == 0) {
        missingAssetClass <- initDF(colnames(missingAssetClass), 1)
    }

    instrumentLink <- paste0(gsub("api", "", session[["location"]]), "resource/details/", missingAssetClass[, "id"])
    instrumentLink <- gsub(" ", "%20", instrumentLink)

    result <- data.frame("Link"=instrumentLink,
                         "Name"=ellipsify(missingAssetClass[, "name"]),
                         "Symbol"=missingAssetClass[, "symbol"],
                         check.names=FALSE,
                         stringsAsFactors=FALSE)


    result[, "Link"] <- paste0("<a href='", result[, "Link"], "'>LINK</a>")

    result <- as.character(emailHTMLTable(result,
                                          provider = "DECAF",
                                          caption="Missing Asset Class",
                                          sourceType = "API"))

    result <- gsub("&#62;LINK&#60;/a&#62;", ">LINK<aya/a>", result)
    result <- gsub("&#60;a href", "<a href", result)

    .UPDATETEXT <- list(GREETINGPLACEHOLDER = greeting,
                        EMAILBODYPLACEHOLDER = "Please find below active instruments which do not have an asset class assigned",
                        CALLTOACTIONPLACEHOLDER = "Go to System",
                        DEPLOYMENT = deployment,
                        URLPLACEHOLDER = url,
                        FINALPARAGRAPHPLACEHOLDER = "Please contact us if you experience any issues or have questions/feedback",
                        ADDRESSPLACEHOLDER = "",
                        GOODBYEPLACEHOLDER = "Best Regards,<br>DECAF TEAM",
                        ADDENDUMPLACEHOLDER = result)

    syncUpdateEmail(template = readLines("../assets/update_email.html"),
                    updateText = .UPDATETEXT,
                    emailParams = emailParams,
                    subject = " DECAF Missing Asset Class: ")
}


##' A function to report a missing or invalid field in resources.
##'
##' This is the description
##'
##' @param session The rdecaf session.
##' @param resources The data-frame of the resources in the decaf instance. Default NULL.
##' @param emailParams The parameters for the email dispatch.
##' @param greeting The greetings string.
##' @param deployment The name of the deployment / client.
##' @param url The url of the deployment.
##' @param gte Greater than or equal to this time (HH:MM:SS) to run this alert.
##' @param lte Less than or equal to this time (HH:MM:SS) to run this alert.
##' @param tz The time-zone for gte and lte.
##' @param stockOnly Shall we check only open positions? Default: TRUE
##' @param emailList Optionally, a vector with email addressess to overwrite emailParams.
##' @param excludeType The ctypes of resources to be excluded. A vector. Default is 'CCY'.
##' @param invalidVals A vector with strings which do not qualify as valid.
##' @param fieldName The name of the field to check.
##' @param ... Any additional arguments.
##' @return Sends email with the alert and returns a message.
##' @export
alertMissingResourceField <- function (session,
                                       resources=NULL,
                                       emailParams,
                                       greeting="Dear Team,",
                                       deployment,
                                       url,
                                       gte="00:00:00",
                                       lte="23:59:59",
                                       tz = "UTC",
                                       stockOnly=TRUE,
                                       emailList=NULL,
                                       excludeType="CCY",
                                       invalidVals=NULL,
                                       fieldName,
                                       ...) {

    ## Check if  parameters are defined:
    if (!hasArg("session") || !hasArg("resources") || !hasArg("emailParams") || !hasArg("deployment") || !hasArg("url")) {
        stop("Need to define session / resources / emailsParams / deployment / url")
    }

    ## Overwrite the email recipients:
    if (!is.null(emailList)) {
        emailParams[["emailList"]] <- emailList
    }

    ## Is it alert time:
    itsAlertTime <- itsTime(tz=tz, gte=gte, lte=lte)

    ## If not, return NULL:
    if (!itsAlertTime) {
        return(NULL)
    }

    ## If by stock only, filter resources by stocks:
    if (stockOnly) {

        ## Get the stocks:
        stocks <- as.data.frame(getResource("stocks", params=list("page_size"=1, "format"="csv"), session=session))

        ## Get the resources by stock:
        resources <- getResourcesByStock(stocks, session=session, getUnderlying=FALSE)

    } else {
        resources <- getDBObject("resources", session=session)
    }

    ## Exclude ctypes from consideration:
    resources <- resources[apply(mgrep(resources[, "ctype"], excludeType), MARGIN=1, function(x) all(x == "0")), ]

    ## Reduce the resource column to the necessary ones:
    resources <- resources[, c("symbol", fieldName, "id", "ctype", "name")]

    ## Get the NA, empty and invalid values:
    isInvalid <- isNAorEmpty(resources[, fieldName]) | apply(mgrep(resources[, fieldName], invalidVals), MARGIN=1, function(x) any(x != "0"))

    ## Reduce the resources to the invalids:
    missingField <- resources[isInvalid, ]

    ## If no invalids, initialise an NA row:
    if (NROW(missingField) == 0) {
        missingField <- initDF(colnames(missingField), 1)
    }

    ## Construct the instrument links:
    instrumentLink <- paste0(gsub("api", "", session[["location"]]), "resource/details/", missingField[, "id"])
    instrumentLink <- gsub(" ", "%20", instrumentLink)

    ## Prepare the result data frame:
    result <- data.frame("Link"=instrumentLink,
                         "Name"=ellipsify(missingField[, "name"]),
                         "Symbol"=missingField[, "symbol"],
                         check.names=FALSE,
                         stringsAsFactors=FALSE)

    ## Parse the Link field:
    result[, "Link"] <- paste0("<a href='", result[, "Link"], "'>LINK</a>")

    ## Create the html table:
    result <- as.character(emailHTMLTable(result,
                                          provider = "DECAF",
                                          caption=sprintf("Missing %s", capitalise(fieldName)),
                                          sourceType = "API"))

    ## Parse the html text:
    result <- gsub("&#62;LINK&#60;/a&#62;", ">LINK<aya/a>", result)
    result <- gsub("&#60;a href", "<a href", result)

    ## Prepare the inline text:
    .UPDATETEXT <- list(GREETINGPLACEHOLDER = greeting,
                        EMAILBODYPLACEHOLDER = sprintf("Please find below active instruments which do not have an %s assigned", fieldName),
                        CALLTOACTIONPLACEHOLDER = "Go to System",
                        DEPLOYMENT = deployment,
                        URLPLACEHOLDER = url,
                        FINALPARAGRAPHPLACEHOLDER = "Please contact us if you experience any issues or have questions/feedback",
                        ADDRESSPLACEHOLDER = "",
                        GOODBYEPLACEHOLDER = "Best Regards,<br>DECAF TEAM",
                        ADDENDUMPLACEHOLDER = result)

    ## Sent the email:
    syncUpdateEmail(template=update_email_template,
                    updateText = .UPDATETEXT,
                    emailParams = emailParams,
                    subject=sprintf(" DECAF Missing %s: ", capitalise(fieldName)))


    ## Return with message:
    return("Email Sent!")

}

##' A function that sends out a generic DECAF email alert given parameters.
##'
##' This is the description
##'
##' @param session list of rdecaf session.
##' @param data list containing two optional data frame elements (summary or first element displays in body, details or second in attachments). Default NULL for just a message.
##' @param emailParams list of the parameters for the email dispatch. INCLUDE SUBJECT HERE.
##' @param dtPath the path containing the details/attachment data. Defaults to details.csv in the wd.
##' @param snd date object deciding the send date. Defaults to present.
##' @param wdw vector of the time period in which to run the function. Defaults to 24H given a vector of c(gte,lte).
##' @param dte string of the weekday name of the day in which to run this alert. Defaults to NULL for all days.
##' @param tz string of the time-zone for gte and lte. Defaults to Asia/Singapore.
##' @param noBody boolean dictating whether there should be an email body printout of the summary df. Defaults to FALSE.
##' @param ... Any additional arguments.
##' @return Sends email with the alert.
##' @examples
##' df <- data.frame(parent=c(rep("A",30),rep("B",30),rep("c",30)),child=sample(1:10000,90))
##' emailParams <- list("sendEmail" = TRUE,"from" = "info@telostat.com","emailList" = "andre@telostat.com","isLocal" = FALSE, "subject" = "Example Alert")
##' alertEmail(session=session,data=list("summary"=df %>% dplyr::group_by(parent) %>% dplyr::summarize(v=sum(child)),"details"=df),emailParams=emailParams,wdw=c("23:30:00","23:59:00"),dte="Saturday")
##' @export
alertEmail <- function(session,
                       data=NULL,                    
                       emailParams,
                       dtPath="details.csv",
                       snd=Sys.Date(),               
                       wdw=c("00:00:00","23:59:00"), 
                       dte=NULL,                     
                       tz="Asia/Singapore",
                       noBody=FALSE,
                       ...
                      ) {

    ## Is it alert time?
    itsAlertTime <- itsTime(tz = tz, gte = wdw[1], lte = wdw[length(wdw)]) 
    itsAlertTime || return(NULL)
    
    itsAlertDate <- weekdays(snd) %in% dte | is.null(dte)
    itsAlertDate || return(NULL)

    deployment <- getDepName(session)
    
    addendum   <- ""
    attachment <- NULL

    summEqAttach <- FALSE

    if(!is.null(data)) {
        summary  <- data[[1]]
        addendum <- emailHTMLTable(summary,
                                   provider=deployment,
                                   caption="",
                                   sourceType="API"
                                  )
        addendum <- stringr::str_replace_all(addendum,"&#60;","<")
        addendum <- stringr::str_replace_all(addendum,"&#62;",">")
              
        detail <- data[[length(data)]] 
        write_csv(detail, file=dtPath)
        attachment <- dtPath

        summEqAttach <- isTRUE(dplyr::all_equal(summary,detail))
        
    }

    if(summEqAttach) {

      if(noBody) {
        addendum <- ""
      }
      else {
        attachment <- NULL
      }

    }

    ## Construct the content of the alert email:
    .UPDATETEXT <- list("GREETINGPLACEHOLDER"="Dear Team",
                        "EMAILBODYPLACEHOLDER"="This is a autogenerated alert email triggered. Find below the alert details",
                        "CALLTOACTIONPLACEHOLDER"="Go to System",
                        "DEPLOYMENT"=deployment,
                        "URLPLACEHOLDER"=paste0("https://",deployment,".decafhub.com"),
                        "FINALPARAGRAPHPLACEHOLDER"="",
                        "ADDRESSPLACEHOLDER"="",
                        "GOODBYEPLACEHOLDER"="Best Regards,<br>DECAF TEAM",
                        "ADDENDUMPLACEHOLDER"=addendum
                        )

    ## Run sync email report:
    if(is.null(emailParams[["subject"]])) {

    syncUpdateEmail(template=update_email_template,
                    updateText=.UPDATETEXT,
                    emailParams=emailParams,
                    attachments=attachment
                    )

    return(NULL)

    }

    syncUpdateEmail(template=update_email_template,
                updateText=.UPDATETEXT,
                emailParams=emailParams,
                subject=emailParams[["subject"]],
                attachments=attachment
                )


}

##' A function to report a missing or invalid field in resources.
##'
##' This is the description
##'
##' @param session The rdecaf session.
##' @param resources The data-frame of the resources in the decaf instance. Default NULL.
##' @param emailParams The parameters for the email dispatch.
##' @param greeting The greetings string.
##' @param deployment The name of the deployment / client.
##' @param url The url of the deployment.
##' @param gte Greater than or equal to this time (HH:MM:SS) to run this alert.
##' @param lte Less than or equal to this time (HH:MM:SS) to run this alert.
##' @param tz The time-zone for gte and lte.
##' @param stockOnly Shall we check only open positions? Default: TRUE
##' @param emailList Optionally, a vector with email addressess to overwrite emailParams.
##' @param excludeType The ctypes of resources to be excluded. A vector. Default is 'CCY'.
##' @param invalidVals A vector with strings which do not qualify as valid.
##' @param fieldName The name of the field to check.
##' @param ... Any additional arguments.
##' @return Sends email with the alert and returns a message.
##' @export
alertMissingResourceFieldV2 <- function (session,
                                       resources=NULL,
                                       emailParams,
                                       greeting="Dear Team,",
                                       deployment,
                                       url,
                                       gte="00:00:00",
                                       lte="23:59:59",
                                       tz = "UTC",
                                       stockOnly=TRUE,
                                       emailList=NULL,
                                       excludeType="CCY",
                                       invalidVals=NULL,
                                       fieldName,
                                       ...) {

    ## Check if  parameters are defined:
    if (!hasArg("session") || !hasArg("resources") || !hasArg("emailParams") || !hasArg("deployment") || !hasArg("url") || !hasArg("fieldName")) {
        stop("Need to define session / resources / emailsParams / deployment / url / fieldName")
    }

    ## Overwrite the email recipients:
    if (!is.null(emailList)) {
        emailParams[["emailList"]] <- emailList
    }

    ## Is it alert time:
    itsAlertTime <- itsTime(tz=tz, gte=gte, lte=lte)

    ## If not, return NULL:
    if (!itsAlertTime) {
        return(NULL)
    }

    ## If by stock only, filter resources by stocks:
    if (stockOnly) {

        ## Get the stocks:
        stocks <- as.data.frame(getResource("stocks", params=list("page_size"=1, "format"="csv"), session=session))

        ## Get the resources by stock:
        resources <- getResourcesByStock(stocks, session=session, getUnderlying=FALSE)

    } else {
        resources <- getDBObject("resources", session=session)
    }

    ## Exclude ctypes from consideration:
    resources <- resources[apply(mgrep(resources[, "ctype"], excludeType), MARGIN=1, function(x) all(x == "0")), ]

    ## Reduce the resource column to the necessary ones:
    resources <- resources[, c("symbol", fieldName, "id", "ctype", "name")]

    ## Get the NA, empty and invalid values:
    invalidVals <- safeNull(invalidVals)
    isInvalid   <- isNAorEmpty(resources[, fieldName]) | apply(mgrep(resources[, fieldName], invalidVals), MARGIN=1, function(x) any(x != "0"))

    ## Reduce the resources to the invalids:
    missingField <- resources[isInvalid, ]

    ## If no invalids, initialise an NA row:
    if (NROW(missingField) == 0) {
        missingField <- initDF(colnames(missingField), 1)
    }

    ## Construct the instrument links:
    instrumentLink <- paste0(gsub("api", "", session[["location"]]), "resource/details/", missingField[, "id"])
    instrumentLink <- gsub(" ", "%20", instrumentLink)

    ## Prepare the result data frame:
    result <- data.frame("Link"=instrumentLink,
                         "Name"=ellipsify(missingField[, "name"]),
                         "Symbol"=missingField[, "symbol"],
                         check.names=FALSE,
                         stringsAsFactors=FALSE)

    ## Parse the Link field:
    result[, "Link"] <- paste0("<a href='", result[, "Link"], "'>LINK</a>")

    ## Run the email using function above
    alertEmail(session,
               data=list("summary"=result),                    
               emailParams=emailParams,,               
               wdw=c(gte,lte),                     
               tz=tz
              )       

    ## Return with message:
    return("Email Sent!")

}


data(update_email_template, envir=environment())
